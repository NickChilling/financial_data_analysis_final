setwd("c:/Users/AresL/Desktop/financial_data_analysis_final/data")
library(tseries)
da1 = read.csv("上证50.csv", header = T)
head(da1)
logSZPri = log((da1[c(168 : 2167), 3]))
head(logSZPri)
logZXBPri = log(as.numeric(da2[c(167 : 2166), 2]))
# logZXBPri = log(as.numeric(da2[c(167 : 2166), 2]))
tdx = c(1: 2000)/250 + 2010
# par(mfol=c(4, 1))
plot(tdx, logSZPri, xlab = 'day', ylab = 'ln(price)', type='l')
title(main = '上证50指数变化')
# plot(tdx, logZXBPri, xlab = 'day', ylab = 'ln(price)', type='l')
# title(main = 'zhongxiaoban')
dlogSZPri = diff(logSZPri) #做一阶差分
# dlogZXBPri = diff(logZXBPri)
adf.test(dlogSZPri) # 在5%的显著水平下拒绝原假设，一阶差分后数据平稳
par(mfol = c(2, 1))
par(mfcol = c(2, 1))
acf(dlogSZPri, lag = 20)
pacf(dlongSZPri, lag = 20)
pacf(dlogSZPri, lag = 20)
par(mfcol = c(1, 2))
acf(dlogSZPri, lag = 20)
pacf(dlogSZPri, lag = 20)
install.packages('forcast')
install.packages('forecast')
library(forecast)
# acf(dlogZXBPri, lag = 20)
# pacf(dlogZXBPri, lag = 20)
SZmodel_arima = auto.arima(dlogSZPri)
SZmodel_arima
# acf(dlogZXBPri, lag = 20)
# pacf(dlogZXBPri, lag = 20)
# 观察数据ar使用3阶，ma采用两阶，建立arima(3, 0, 2)模型
SZ_model = arima(dlogSZPri, order = c(3, 0, 2), include.mean = F)
SZ_model
Box.test(SZ_model$residuals)
plot(forecast(SZ_model, h = 5))
forecast(SZ_model, h = 5)
SZ_arima_forecast = forecast(SZ_model, h = 5)
install.packages('PerformanceAnalytics')
#计算原本数据的对数收益率
rate = periodReturn(da1$close, period = 'daily', type = 'log')
install.packages("quantmod")
install.packages("quantmod")
library(PerformanceAnalytics)
#计算原本数据的对数收益率
rate = periodReturn(da1$close, period = 'daily', type = 'log')
library(quantmod)
#计算原本数据的对数收益率
rate = periodReturn(da1$close, period = 'daily', type = 'log')
