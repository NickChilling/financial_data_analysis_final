setwd("c:/Users/AresL/Desktop/financial_data_analysis_final/data")
library(tseries)
library(forecast)
da1 = read.csv("上证50.csv", header = T)
head(da1)
logSZ50Pri = log((da1[c(168: 2167), 3]))
head(logSZ50Pri)
tdx = c(1: 2000)/250 + 2010
plot(tdx, logSZ50Pri, xlab = 'day', ylab = 'ln(price)', type='l')  #TODO 输出的图放在graph/下面
title(main = '上证50指数变化')
dlogSZ50Pri = diff(logSZ50Pri) #做一阶差分
adf.test(dlogSZ50Pri) # 在5%的显著水平下拒绝原假设，一阶差分后数据平稳  # TODO adf检验的结果保存为文本放到graph/下面
par(mfcol = c(1, 2))
acf(dlogSZ50Pri, lag = 20) #TODO 同上
pacf(dlogSZ50Pri, lag = 20)
SZ50_model = arima(dlogSZ50Pri, order = c(3, 0, 2), include.mean = F)
SZ50_model
Box.test(SZ50_model$residuals) # p值显著大于0.05，残差为白噪声序列，选取的模型合适，不需要使用garch模型  #TODO 检验结果保存
#计算原本数据的对数收益率
logr = diff(log(da1[c(2168:2468), 3]))
SZ50_arima_forecast = forecast(SZ50_model, h = 250)
# 短期预测
SZ50_arima_forecast = forecast(SZ50_model, h = 250)
plot.forecast(SZ50_arima_forecast)
?plot.forecast
install.packages("ggplot2")
install.packages("ggplot2")
setwd("c:/Users/AresL/Desktop/financial_data_analysis_final/data")
library(tseries)
library(forecast)
library(ggplot2)
da1 = read.csv("上证50.csv", header = T)
head(da1)
logSZ50Pri = log((da1[c(168: 2167), 3]))
head(logSZ50Pri)
tdx = c(1: 2000)/250 + 2010
plot(tdx, logSZ50Pri, xlab = 'day', ylab = 'ln(price)', type='l')  #TODO 输出的图放在graph/下面
title(main = '上证50指数变化')
dlogSZ50Pri = diff(logSZ50Pri) #做一阶差分
adf.test(dlogSZ50Pri) # 在5%的显著水平下拒绝原假设，一阶差分后数据平稳  # TODO adf检验的结果保存为文本放到graph/下面
par(mfcol = c(1, 2))
acf(dlogSZ50Pri, lag = 20) #TODO 同上
pacf(dlogSZ50Pri, lag = 20)
# 观察数据ar使用3阶，ma采用两阶，建立arima(3, 0, 2)模型
SZ50_model = arima(dlogSZ50Pri, order = c(3, 0, 2), include.mean = F)
SZ50_model
Box.test(SZ50_model$residuals) # p值显著大于0.05
#计算原本数据的对数收益率
logr = diff(log(da1[c(2168:2468), 3]))
# 短期预测
SZ50_arima_forecast = forecast(SZ50_model, h = 250)
plot.forecast(SZ50_arima_forecast)
autoplot(SZ50_arima_forecast)
install.packages("zoo")
install.packages("zoo")
library(zoo)
setwd("c:/Users/AresL/Desktop/financial_data_analysis_final/data")
library(tseries)
library(forecast)
library(ggplot2)
da1 = read.csv("上证50.csv", header = T)
head(da1)
logSZ50Pri = log((da1[c(168: 2167), 3]))
head(logSZ50Pri)
tdx = c(1: 2000)/250 + 2010
plot(tdx, logSZ50Pri, xlab = 'day', ylab = 'ln(price)', type='l')  #TODO 输出的图放在graph/下面
title(main = '上证50指数变化')
dlogSZ50Pri = diff(logSZ50Pri) #做一阶差分
adf.test(dlogSZ50Pri) # 在5%的显著水平下拒绝原假设，一阶差分后数据平稳  # TODO adf检验的结果保存为文本放到graph/下面
par(mfcol = c(1, 2))
acf(dlogSZ50Pri, lag = 20) #TODO 同上
pacf(dlogSZ50Pri, lag = 20)
# 观察数据ar使用3阶，ma采用两阶，建立arima(3, 0, 2)模型
SZ50_model = arima(dlogSZ50Pri, order = c(3, 0, 2), include.mean = F)
SZ50_model
Box.test(SZ50_model$residuals) # p值显著大于0.05，残差为白噪声序列，选取的模型合适，不需要使用garch模型  #TODO 检验结果保存
#计算原本数据的对数收益率
logr = diff(log(da1[c(2168:2468), 3]))
# 短期预测
SZ50_arima_forecast = forecast(SZ50_model, h = 250)
?adf.test
? adf.test
setwd("c:/Users/AresL/Desktop/financial_data_analysis_final/data")
library(tseries)
install.packages("zoo")
setwd("c:/Users/AresL/Desktop/financial_data_analysis_final/data")
library(tseries)
library(forecast)
library(ggplot2)
da1 = read.csv("上证50.csv", header = T)
head(da1)
logSZ50Pri = log((da1[c(168: 2167), 3]))
head(logSZ50Pri)
tdx = c(1: 2000)/250 + 2010
plot(tdx, logSZ50Pri, xlab = 'day', ylab = 'ln(price)', type='l')  #TODO 输出的图放在graph/下面
title(main = '上证50指数变化')
dlogSZ50Pri = diff(logSZ50Pri) #做一阶差分
adf.test(dlogSZ50Pri) # 在5%的显著水平下拒绝原假设，一阶差分后数据平稳  # TODO adf检验的结果保存为文本放到graph/下面
par(mfcol = c(1, 2))
par(mfcol = c(1, 2))
acf(dlogSZ50Pri, lag = 20) #TODO 同上
pacf(dlogSZ50Pri, lag = 20)
# 观察数据ar使用3阶，ma采用两阶，建立arima(3, 0, 2)模型
SZ50_model = arima(dlogSZ50Pri, order = c(3, 0, 2), include.mean = F)
SZ50_model
Box.test(SZ50_model$residuals) # p值显著大于0.05，残差为白噪声序列，选取的模型合适，不需要使用garch模型  #TODO 检验结果保存
#计算原本数据的对数收益率
logr = diff(log(da1[c(2168:2468), 3]))
# 短期预测
SZ50_arima_forecast = forecast(SZ50_model, h = 250)
plot.forecast(SZ50_arima_forecast)
plot(SZ50_arima_forecast)
autoplot(SZ50_arima_forecast)
plot(logr,type= 'l',main = "comparison", xlab = 'time series', ylab='log return') # 实际值
lines(SZ50_arima_forecast[[4]], col= 'red')
#TODO 画图看一下, 更直观
# 画图样例
plot(logr,type= 'l',main = "comparison", xlab = 'time series', ylab='log return') # 实际值
lines(SZ50_arima_forecast[[4]], col= 'red') # 预测值
lines(SZ50_arima_forecast[[4]], col= 'red') # 预测值
plot(logr,type= 'l',main = "comparison", xlab = 'time series', ylab='log return') # 实际值
lines(SZ50_arima_forecast[[4]], col= 'red') # 预测值
plot(logr,type= 'l',main = "comparison", xlab = 'time series', ylab='log return') # 实际值
autoplot(SZ50_arima_forecast[[4]], col= 'red') # 预测值
#TODO 画图看一下, 更直观
# 画图样例
plot(logr,type= 'l',main = "comparison", xlab = 'time series', ylab='log return') # 实际值
autoplot(SZ50_arima_forecast[[4]], col= 'red') # 预测值
plot(logr,type= 'l',main = "comparison", xlab = 'time series', ylab='log return') # 实际值
lines(SZ50_arima_forecast[[4]], col= 'red') # 预测值
#TODO 画图看一下, 更直观
# 画图样例
par(mfcol = c(1, 1))
plot(logr,type= 'l',main = "comparison", xlab = 'time series', ylab='log return') # 实际值
lines(SZ50_arima_forecast[[4]], col= 'red') # 预测值
abline(SZ50_arima_forecast[[4]], col= 'red') # 预测值
plot(logr,type= 'l',main = "comparison", xlab = 'time series', ylab='log return') # 实际值
abline(SZ50_arima_forecast[[4]], col= 'red') # 预测值
lines(SZ50_arima_forecast[[4]], col= 'red') # 预测值
lines(SZ50_arima_forecast, col= 'red') # 预测值
autoplot(SZ50_arima_forecast)
#TODO 画图看一下, 更直观
# 建立向量将预测值，取出方便画图
# 画图样例
par(mfcol = c(1, 1))
#TODO 画图看一下, 更直观
# 建立向量将预测值，取出方便画图
forecast.val = c(1: 250)
for(i in 1: 250) {
forecast.val[i] = SZ50_arima_forecast[[4]][i]
}
head(forecast.val)
lines(forecast.val, col= 'red') # 预测值
plot(logr,type= 'l',main = "comparison", xlab = 'time series', ylab='log return') # 实际值
lines(forecast.val, col= 'red') # 预测值
plot(logr[c(1: 250)],type= 'l',main = "comparison", xlab = 'time series', ylab='log return') # 实际值
lines(forecast.val, col= 'red') # 预测值
tail(forecast.val)
setwd("c:/Users/AresL/Desktop/financial_data_analysis_final/data")
library(tseries)
library(forecast)
da2 = read.csv("中小板.csv", header = T)
head(da2)
logZXBPri = log((da2[c(168: 2167), 3]))
head(logZXBPri)
tdx = c(1: 2000)/250 + 2010
plot(tdx, logZXBPri, xlab = 'day', ylab = 'ln(price)', type='l')
title(main = '中小板指数变化')
dlogZXBPri = diff(logZXBPri) #做一阶差分
adf.test(dlogZXBPri) # 在5%的显著水平下拒绝原假设，一阶差分后数据平稳
par(mfcol = c(1, 2))
acf(dlogZXBPri, lag = 20)
pacf(dlogZXBPri, lag = 20)
ZXB_model = arima(dlogZXBPri, order = c(2, 0, 1), include.mean = F)
ZXB_model
Box.test(ZXB_model$residuals) # p值显著大于0.05，残差为白噪声序列，选取的模型合适，不需要用garch模型
#计算原本数据的对数收益率
logr = diff(log(da2[c(2168:2468), 3]))
# 短期预测
ZXB_arima_forecast = forecast(ZXB_model, h = 250)
auto(ZXB_arima_forecast)
library(ggplots)
library(ggplot2)
autoplot(ZXB_arima_forecast)
forecast.val = c(1: 250)
for(i in 1: 250) {
forecast.val[i] = ZXB_arima_forecast[[4]][i]
}
head(forecast.val)
tail(forecast.val)
# 画图样例
par(mfcol = c(1, 1))
plot(logr[c(1: 250)],type= 'l',main = "comparison", xlab = 'time series', ylab='log return') # 实际值
lines(forecast.val, col= 'red') # 预测值
setwd("c:/Users/AresL/Desktop/financial_data_analysis_final/data")
library(tseries)
library(forecast)
da3 = read.csv("沪深300.csv", header = T)
head(da3)
logHSPri = log((da3[c(168: 2167), 3]))
head(logHSPri)
tdx = c(1: 2000)/250 + 2010
plot(tdx, logHSPri, xlab = 'day', ylab = 'ln(price)', type='l')
title(main = '沪深300指数变化')
dlogHSPri = diff(logHSPri) #做一阶差分
adf.test(dlogHSPri) # 在5%的显著水平下拒绝原假设，一阶差分后数据平稳
par(mfcol = c(1, 2))
acf(dlogHSPri, lag = 20)
pacf(dlogHSPri, lag = 20)
setwd("c:/Users/AresL/Desktop/financial_data_analysis_final/data")
library(tseries)
library(forecast)
da4 = read.csv("深证.csv", header = T)
head(da4)
logSZPri = log((da4[c(168: 2167), 3]))
head(logSZPri)
tdx = c(1: 2000)/250 + 2010
plot(tdx, logSZPri, xlab = 'day', ylab = 'ln(price)', type='l')
title(main = '深证指数变化')
setwd("c:/Users/AresL/Desktop/financial_data_analysis_final/data")
library(tseries)
library(forecast)
da4 = read.csv("深证.csv", header = T)
head(da4)
logSZPri = log((da4[c(168: 2167), 3]))
head(logSZPri)
tdx = c(1: 2000)/250 + 2010
plot(tdx, logSZPri, xlab = 'day', ylab = 'ln(price)', type='l')
title(main = '深证指数变化')
dlogSZPri = diff(logSZPri) #做一阶差分
adf.test(dlogSZPri) # 在5%的显著水平下拒绝原假设，一阶差分后数据平稳
par(mfcol = c(1, 2))
acf(dlogSZPri, lag = 20)
pacf(dlogSZPri, lag = 20)
